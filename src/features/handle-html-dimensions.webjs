function htmlDimensionsFeature(context) {
  var postMessage = context.postMessage;
  var oldDimensions = {
    layoutViewport: { width: 0, height: 0 },
    content: { width: 0, height: 0 },
    scrollable: { width: 0, height: 0 }
  };

  function dimensionsAreEqual(d1, d2) {
    return (
      d1.layoutViewport.width === d2.layoutViewport.width &&
      d1.layoutViewport.height === d2.layoutViewport.height &&
      d1.content.width === d2.content.width &&
      d1.content.height === d2.content.height &&
      d1.scrollable.width === d2.scrollable.width &&
      d1.scrollable.height === d2.scrollable.height
    );
  }

  function postSize() {
    var layoutViewport = {
      width: Math.round(document.documentElement.clientWidth),
      height: Math.round(document.documentElement.clientHeight)
    };
    var content = {
      width: Math.round(document.documentElement.offsetWidth),
      height: Math.round(document.documentElement.offsetHeight)
    };
    var scrollable = {
      width: Math.round(document.documentElement.scrollWidth),
      height: Math.round(document.documentElement.scrollHeight)
    };
    var dimensions = {
      layoutViewport: layoutViewport,
      scrollable: scrollable,
      content: content
    };
    if (!dimensionsAreEqual(oldDimensions, dimensions)) {
      postMessage(dimensions);
      oldDimensions = dimensions;
    }
  }
  postSize();
  window.onresize = postSize;
  // trigger when DOM changes
  var MutationObserver =
    window['MutationObserver'] || window['WebKitMutationObserver'];
  if (MutationObserver) {
    var observer = new MutationObserver(postSize);
    observer.observe(document, {
      subtree: true,
      attributes: true
    });
  } else {
    context.warn(
      "This browser doesn't support MutationObserver." +
        'The dimensions will still be read every 100ms and committed when a change is identified.'
    );
  }
  setInterval(postSize, 100);
}
