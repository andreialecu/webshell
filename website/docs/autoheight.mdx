---
id: autoheight
sidebar_label: Autoheight WebView
title: Autoheight WebView
---

import { Subtitle } from '../components/Subtitle';
import { APIReference } from '../components/APIReference';
import { ReactReference, WebView } from '../components/ReactReference';
import { APIBox } from '../components/APIBox';
import { DualCodeSource } from '../components/CodeSource';

> **Craft a Full-Featured, Dynamic Autoheight WebView-based component.**

This component height automatically and dynamically adapts to the page height,
anytime the DOM changes.

<APIBox reference="useAutoheight" type="function" />

## Highlights

An incredibly modular, state-of-the-art implementation which goes beyond many prexisting solutions.

- The **width** of the viewport will grow to the
  available horizontal space and won't need to be specified. You can
  override this behavior by setting explicit `width` as a
  parameter attribute of <APIReference reference="useAutoheight" type="function" /> hook.
- The **height** of the viewport, also called layout
  height, will dynamically adapts to the content height, which has
  been constrained by the layout width as we have just mentioned! It
  means that anytime the content changes or the layout width changes,
  such as in screen rotations, the layout height will get updated.
- This hook will rely on <APIReference reference="HandleHTMLDimensionsFeature" type="variable" /> to use the best API
  available in the browser
  **and dynamically adapt layout to content size**. In
  order of preference,
  [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver),
  [MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
  and finally, polling on a regular interval.

:::note
Read [Overcoming the Autoheight WebView
Challenge](/blog/2020/09/15/overcoming-the-autoheight-webview-challenge) to demystify all the magic behind this hook.
:::

## Basic Example

As previously stated, <APIReference reference="useAutoheight" type="function" />
requires *a minima* injection of a <APIReference reference="HandleHTMLDimensionsFeature" type="variable" /> in the shell to fetch content dimensions:

<DualCodeSource
  jsx
  titleBase="MinimalAutoheightWebView"
  sourceBase={'minimal-autoheight'}
/>

## Caveats and their Workarounds

### Mobile Virtual Viewport

In some circumstances, the mobile browser might use a virtual
viewport much larger then the available width in the <WebView />, often
around 980px for websites which have been built for desktop. For
this autoheight component to be reliable, you must ensure that the
content has a [meta viewport element](https://www.w3schools.com/css/css_rwd_viewport.asp)
in the header.

:::tip solution
This can be enforced by setting responsive layout with <APIReference reference="ForceResponsiveViewportFeature" type="variable" />.

```js {4}
const Webshell = makeWebshell(
  WebView,
  new HandleHTMLDimensionsFeature(),
  new ForceResponsiveViewportFeature({ maxScale: 1 })
);
```

:::

### Cyclic Size Constraints &infin;

Because the **viewport height** now depends on **content heigh**, you must never have a **body** element
height depending on viewport height, such as:

```css title="evil.css"
body {
  height: 100vh;
}
```

<div className="margin-bottom--md" style={{textAlign: 'center', fontStyle: 'italic'}}>or</div>

```css title="evil.css"
body {
  height: 100%;
}
```

That is an evil cyclic dependency ready to cast an infinite loop!

:::tip solution
Body width and height can be forced to
**auto** with <APIReference reference="ForceElementSizeFeature" type="variable" />.

```js {4,5,6,7}
const Webshell = makeWebshell(
  WebView,
  new HandleHTMLDimensionsFeature(),
  new ForceElementSizeFeature({
    target: 'body',
    heightValue: 'auto',
    widthValue: 'auto'
  })
);
```

:::

## Robust Example

In this example, we use the two tips listed in above Caveats section to provide a much resilient implementation.

<DualCodeSource
  jsx
  titleBase="ResilientAutoheightWebView"
  sourceBase="resilient-autoheight"
/>

## Integration with ScrollView

More often than not, an autoheight feature is needed to embed the <WebView /> along with
content of unpredictable length, and a <ReactReference name="ScrollView" type="class" /> works just fine.
This section summarize best practices and tricks for a perfect integration.

### Recommended ScrollView Props Values

| Prop                  | Value   | Rationale                                                                                                                                                                                                                                                                                  |
| :-------------------- | :------ | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `pinchGestureEnabled` | `false` | Enabling pinch (the default) will conflict with the pinch-to-zoom feature provided by <APIReference reference="ForceResponsiveViewportFeature" type="variable" /> `maxScale` option. When `maxScale` is above `1`, it will allow for pinch to zoom gestures up to the provided zoom level. |
| `horizontal`          | `false` | When the web page is ill-designed (not-responsive), the content might overflows horizontally. We suggest to avoid nesting components providing scroll in the same direction, unless necessary.                                                                                             |

### Handling `hashchange` Events

However, scroll to hash on link press, for example:

```html
<a href="#head">go to top</a>
```

will not work, because the underlying <WebView /> will not have vertical scroll anymore.

:::tip solution
You can register a prop to listen to [haschange](https://developer.mozilla.org/en-US/docs/Web/API/Window/hashchange_event) events with <APIReference reference="HandleHashChangeFeature" type="variable" />.

```jsx {4}
const Webshell = makeWebshell(
  WebView,
  new HandleHTMLDimensionsFeature(),
  new HandleHashChangeFeature({ shouldResetHashOnEvent: true })
);
```

:::

After that, you must implement the desired behavior, that is to scroll to the
desired DOM element when a hashchange event is fired, while accounting for the space
occupied by components above the shell, inside the <ReactReference name="ScrollView" type="class" />. Below is a complete
example:

<DualCodeSource
  jsx
  sourceBase="scrollview"
  titleBase="AutoheightWebViewInScrollView"
/>
