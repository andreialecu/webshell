---
title: The Future of Webshell (v3+)
author: Jules Sam. Randolph
author_title: Freelance React developer
author_url: https://github.com/jsamr
author_image_url: https://avatars1.githubusercontent.com/u/3646758?s=460&u=f699d25514156aa9b975837a52daf135449e43d8&v=4
tags: [webshell, react native, future]
---

import { Webshell } from '../components/Webshell';

This post will be regularly updated to track the main features scheduled for <Webshell />.

## Native to DOM Communication

Currently, features can inject scripts which will create events, and offer props to handle those events.
What we'd like to provide is a way to communicate imperatively _from_ the shell _to_ the DOM. Something like this:

```jsx title="MyComponent.jsx"
import * as React from 'react';
import { Feature1 } from './Feature1';

const feature1 = new Feature1();
const Webshell = makeWebshell(WebView, feature1);

export const MyComponent = (props) => {
  const bridge = React.useRef();
  React.useEffect(() => {
    // props.user must be JSON-serializable
    bridge.postDOMMessage(feature1.instanceId, props.user);
  }, [props.user]);
  return <Webshell bridge={bridge} />;
};
```

And on the Web side:

```js title="feature1.webjs"
function feature1(context) {
  context.onShellMessage(function (user) {
    console.info(user); // Prints user!
  });
}
```

## Feature Cardinality

- specify the cardinality of a feature (how many instances can co-exist). We
  are planning to get inspiration from [multi-instance plugins in
  docusaurus](https://v2.docusaurus.io/docs/using-plugins#multi-instance-plugins-and-plugin-ids).

## Inter-feature Script Communication

Feature scripts could add listeners to events emitted by other features.

```js title="listening-feature.webjs"
function listeningFeature(context) {
  function onLinkPress(instanceId, target) {
    console.info(target.uri + ' pressed!');
  }
  context.addDOMEventListener('org.myorg/webshell.link-press', onLinkPress);
}
```

## Feature Composition

## Passing Props to Feature Scripts

Features are already customizable with options, which are once-and-for-all
delivered as an argument of the feature function. What we could provide is a way to
declare JSON-serializable props that could be read in Feature Scripts.

### Native Consumption

```jsx title="MyAugmentedWebView"
import React, { ComponentProps } from 'react';
import makeWebshell, { useAutoheight } from '@formidable-webview/webshell';
import WebView from 'react-native-webview';
import { FeatureWithProp } from './FeatureWithProp';

const Webshell = makeWebshell(WebView, new FeatureWithProp());

export default function MyAugmentedWebView(webshellProps: WebshellProps) {
  return <Webshell userId={123654} {...webshellProps} />;
}
```

### Native Implementation

```js title="FeatureWithProp.js"
import featureWithPropScript from './feature-with-prop.webjs';
import { FeatureBuilder } from '@formidable-webview/webshell';

export const FeatureWithProp = new FeatureBuilder({
  defaultOptions: {},
  script: featureWithPropScript,
  featureIdentifier: 'org.myorg/project.feature-with-prop',
  className: 'FeatureWithProp'
})
  .withProp('userId')
  .build();
```

### DOM Implementation

```js title="feature-with-prop.webjs"
function featureWithProp(context) {
  console.info(context.props.userId);
  // 123654
}
```
