---
title: The Future of Webshell (v3+)
author: Jules Sam. Randolph
author_title: Freelance React developer
author_url: https://github.com/jsamr
author_image_url: https://avatars1.githubusercontent.com/u/3646758?s=460&u=f699d25514156aa9b975837a52daf135449e43d8&v=4
tags: [webshell, react native, future]
---

import { Webshell } from '../components/Webshell';

This post will be regularly updated to track the main features scheduled for <Webshell />.

## Native to Web Communication

Currently, features can inject scripts which will create events, and offer props to handle those events.
What we'd like to provide is a way to communicate imperatively _from_ the shell _to_ the Web. Something like this:

### Native Usage

```jsx title="MyComponent.jsx"
import * as React from 'react';
import { makeWebshell } from '@formidable-webview/webshell';
import { Feature1 } from './Feature1';

const feature1 = new Feature1();
const Webshell = makeWebshell(WebView, feature1);

export const MyComponent = (props) => {
  const webHandle = React.useRef();
  React.useEffect(() => {
    // props.user must be JSON-serializable
    webHandle.postMessageToWeb(feature1, 'user', props.user);
  }, [props.user]);
  return <Webshell webHandle={webHandle} />;
};
```

### Native Implementation

```js title="Feature1.js"
import { FeatureBuilder } from '@formidable-webview/webshell';
import script from './Feature1.webjs';

export const Feature1 = new FeatureBuilder({
  script,
  defaultOptions: {},
  featureIdentifier: 'org.myorg/webshell.feature1',
  className: 'Feature1'
})
  .withWebHandler('user')
  .build();
```

### Web Implementation

```js title="Feature1.webjs"
function Feature1(context) {
  context.onShellMessage('user', function (user) {
    console.info(user); // Prints user!
  });
}
```

## Asynchronous Web to Native Communication

### Native Usage

```jsx title="MyComponent.jsx"
import * as React from 'react';
import { makeWebshell } from '@formidable-webview/webshell';
import { AsyncFlatteryFeature } from './AsyncFlatteryFeature';

const flatters = new AsyncFlatteryFeature();
const Webshell = makeWebshell(WebView, flatters);

// This function must return a promise!
function handleAsyncFlattery() {
  return Promise.resolve('I love you too!');
}

export const MyComponent = (props) => {
  return <Webshell onAsyncWebFlattery={handleFlattery} />;
};
```

### Native Implementation

```js title="AsyncFlatteryFeature.js"
import { FeatureBuilder } from '@formidable-webview/webshell';
import script from './AsyncFlatteryFeature.webjs';

export const AsyncFlatteryFeature = new FeatureBuilder({
  script,
  defaultOptions: {},
  featureIdentifier: 'org.myorg/webshell.async-flattery',
  className: 'AsyncFlatteryFeature'
})
  .withAsyncHandlerProp('onAsyncWebFlattery', 'flatters')
  .build();
```

### Web Implementation

```js title="AsyncFlatteryFeature.webjs"
function AsyncFlatteryFeature(context) {
  context
    .postAsyncMessageToShell('flatters', 'I really like you.')
    .then(function (response) {
      console.info(response);
      // 'I love you too!'
    });
}
```

## Asynchronous Native to Web Communication


### Native Usage

```jsx title="MyComponent.jsx"
import * as React from 'react';
import { makeWebshell } from '@formidable-webview/webshell';
import { AsyncFlatteryFeature } from './AsyncFlatteryFeature';

const flatteryFeature = new AsyncFlatteryFeature();
const Webshell = makeWebshell(WebView, flatteryFeature);

export const MyComponent = (props) => {
  const webHandle = React.useRef();
  React.useEffect(() => {
    // props.user must be JSON-serializable
    webHandle
      .postAsyncMessageToWeb(flatteryFeature, 'flatters', 'I really like you!')
      .then(response => console.info(response));
  }, []);
  return <Webshell webHandle={webHandle} />;
};
```

### Native Implementation

```js title="AsyncFlatteryFeature.js"
import { FeatureBuilder } from '@formidable-webview/webshell';
import script from './AsyncFlatteryFeature.webjs';

export const AsyncFlatteryFeature = new FeatureBuilder({
  script,
  defaultOptions: {},
  featureIdentifier: 'org.myorg/webshell.async-flattery',
  className: 'AsyncFlatteryFeature'
})
  .withAsyncWebHandler('flatters')
  .build();
```

### Web Implementation

```js title="AsyncFlatteryFeature.webjs"
function AsyncFlatteryFeature(context) {
  context.onAsyncShellMessage('flatters', function (message) {
    return Promise.resolve('I love you too!')
  });
}
```

## Feature Cardinality

Specify the cardinality of a feature (how many instances can co-exist). We
are planning to get inspiration from [multi-instance plugins in
docusaurus](https://v2.docusaurus.io/docs/using-plugins#multi-instance-plugins-and-plugin-ids).

## Passing Props to Feature Scripts

Features are already customizable with options, which are once-and-for-all
delivered as an argument of the feature function. What we could provide is a way to
declare JSON-serializable props that could be read in Feature Scripts.

### Native Usage

```jsx title="MyAugmentedWebView"
import React, { ComponentProps } from 'react';
import makeWebshell, { useAutoheight } from '@formidable-webview/webshell';
import WebView from 'react-native-webview';
import { FeatureWithProp } from './FeatureWithProp';

const Webshell = makeWebshell(WebView, new FeatureWithProp());

export default function MyAugmentedWebView(webshellProps: WebshellProps) {
  return <Webshell userId={123654} {...webshellProps} />;
}
```

### Native Implementation

```js title="FeatureWithProp.js"
import featureWithPropScript from './feature-with-prop.webjs';
import { FeatureBuilder } from '@formidable-webview/webshell';

export const FeatureWithProp = new FeatureBuilder({
  defaultOptions: {},
  script: featureWithPropScript,
  featureIdentifier: 'org.myorg/project.feature-with-prop',
  className: 'FeatureWithProp'
})
  .withProp('userId')
  .build();
```

### Web Implementation

```js title="feature-with-prop.webjs"
function featureWithProp(context) {
  console.info(context.props.userId);
  // 123654
}
```
